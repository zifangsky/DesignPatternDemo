## 命令模式的定义 ##

命令模式是一个高内聚的模式，其定义为：

> Encapsulate a request as an object,thereby letting you parameterize clients with different requests,queue or log requests,and support undoable operations.（将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。）

命令模式的通用类图如下所示：

![命令模式的通用类图](https://gitee.com/uploads/images/2018/0528/170320_27f0b5d8_737082.png "命令模式的通用类图")

在该类图中，我们可以看到三个角色：

#### Receive接收者角色 ####

该角色就是干活的角色，命令传递到这里是应该被执行的，具体到我们上面的例子中就是Group的三个实现类。

#### Command命令角色 ####

需要执行的所有命令都在这里声明。

#### Invoker调用者角色 ####

接收到命令，并执行命令。在例子中，我（项目经理）就是这个角色。

命令模式比较简单，但是在项目中非常频繁地使用，因为它的封装性非常好，把请求方（Invoker）和执行方（Receiver）分开了，扩展性也有很好的保障，通用代码比较简单。

------

## 命令模式的应用 ##

### 命令模式的优点 ###

#### 类间解耦 ####

调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command抽象类的execute方法就可以，不需要了解到底是哪个接收者执行。

#### 可扩展性 ####

Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。

#### 命令模式结合其他模式会更优秀 ####

命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少Command子类的膨胀问题。

### 命令模式的缺点 ###

命令模式也是有缺点的，请看Command的子类：如果有N个命令，问题就出来了，Command的子类就可不是几个，而是N个，这个类膨胀得非常大，这个就需要读者在项目中慎重考虑使用。

### 命令模式的使用场景 ###

只要你认为是命令的地方就可以采用命令模式，例如，在GUI开发中，一个按钮的点击是一个命令，可以采用命令模式；模拟DOS命令的时候，当然也要采用命令模式；触发－反馈机制的处理等。

